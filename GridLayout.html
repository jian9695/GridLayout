<!DOCTYPE html>
<html>
<head>
<style>
h2 {
  position: relative;
  left: 10%;
  top: 50%;
}

  table {
    border-collapse: collapse;
  }

  table, td, th {
    border: 1px solid black;
    margin: 0;
    padding: 0;
  }

  td {
    max-width: 100%;
    white-space: nowrap;
  }

.fullscreen {
  border: 2px solid red;
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  overflow: auto;
  background: lime; /* Just to visualize the extent */
}

  .container {
    position: relative;
    width: 100%;
    height: 0;
    padding-bottom: 56.25%;
  }

  .video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body id="Body" onload="onPageLoad()" onresize="onResize()">
  <!--<table>
    <tr>
      <td>
        <button height="20px" type="button" onclick="myFunction()">Try it</button>
      </td>
      <td height="100px">
        <div><img id="News" src="https://ichef.bbci.co.uk/news/660/cpsprodpb/B886/production/_110883274_gettyimages-1025376982-1.jpg"></img></div>
      </td>
    </tr>
  </table>-->
  <!--<div style="height: 100px;width:100px;"><img id="News" src="https://ichef.bbci.co.uk/news/660/cpsprodpb/B886/production/_110883274_gettyimages-1025376982-1.jpg"></img></div>-->
  <!--<table style="width:1000px">
    <tr>
      <th>Firstname</th>
      <th>Lastname</th>
    </tr>
    <tr>
      <td style="max-width:20px;">Peter</td>
      <td><div style="width:100%;height:100%;overflow-x: scroll;"><img id="News" src="https://ichef.bbci.co.uk/news/660/cpsprodpb/B886/production/_110883274_gettyimages-1025376982-1.jpg"></img></div></td>
    </tr>
    <tr>
      <td>Lois</td>
      <td>
        <table style="width:100%;">
          <tr>
            <th>Firstname</th>
            <th>Lastname</th>
          </tr>
          <tr>
            <td>Peter</td>
            <td>Griffin</td>
          </tr>
          <tr>
            <td>Lois</td>
            <td style="max-width:300px;"><div style="width:100%;height:100%;overflow-x: scroll;"><img id="News" src="https://ichef.bbci.co.uk/news/660/cpsprodpb/B886/production/_110883274_gettyimages-1025376982-1.jpg"></img></div></td>
          </tr>
        </table>
      </td>
    </tr>
  </table>-->
<!--   <div id="element_1" cell="0 ,0 ,2 ,1" extent="0.000,0.000,0.667,0.333" 
  style="max-width:100px;overflow-x:auto;border-style: solid;background-color:rgb(255, 255, 128);">
    <img id="News" src="https://ichef.bbci.co.uk/news/660/cpsprodpb/B886/production/_110883274_gettyimages-1025376982-1.jpg">
    </img>
  </div> -->

  <div id="element_0" cell="0,0,5,1" extent="0,0,0.6666667,0.3333333" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(214,170,153);">
    <p>{X=0,Y=0,Width=0.6666667,Height=0.3333333}
    0 ,0 ,1 ,5 </p>
    </div>
    <div id="element_1" cell="5,0,2,1" extent="0.6666667,0,0.3333333,0.3333333" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(165,59,63);">
    <p>{X=0.6666667,Y=0,Width=0.3333333,Height=0.3333333}
    0 ,5 ,1 ,2 </p>
    </div>
    <div id="element_2" cell="0,1,2,2" extent="0,0.3333333,0.3333333,0.1666667" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(169,100,225);">
    <p>{X=0,Y=0.3333333,Width=0.3333333,Height=0.1666667}
    1 ,0 ,2 ,2 </p>
    </div>
    <div id="element_3" cell="2,1,1,3" extent="0.3333333,0.3333333,0.1111111,0.3333333" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(179,22,54);">
    <p>{X=0.3333333,Y=0.3333333,Width=0.1111111,Height=0.3333333}
    1 ,2 ,3 ,1 </p>
    </div>
    <div id="element_4" cell="3,1,1,3" extent="0.4444445,0.3333333,0.1111111,0.3333333" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(165,74,113);">
    <p>{X=0.4444445,Y=0.3333333,Width=0.1111111,Height=0.3333333}
    1 ,3 ,3 ,1 </p>
    </div>
    <div id="element_5" cell="4,1,1,3" extent="0.5555556,0.3333333,0.1111111,0.3333333" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(13,115,212);">
    <p>{X=0.5555556,Y=0.3333333,Width=0.1111111,Height=0.3333333}
    1 ,4 ,3 ,1 </p>
    </div>
    <div id="element_6" cell="5,1,2,1" extent="0.6666667,0.3333333,0.3333333,0.08333334" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(83,114,165);">
    <p>{X=0.6666667,Y=0.3333333,Width=0.3333333,Height=0.08333334}
    1 ,5 ,1 ,2 </p>
    </div>
    <div id="element_7" cell="5,2,2,1" extent="0.6666667,0.4166667,0.3333333,0.08333334" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(175,246,34);">
    <p>{X=0.6666667,Y=0.4166667,Width=0.3333333,Height=0.08333334}
    2 ,5 ,1 ,2 </p>
    </div>
    <div id="element_8" cell="0,3,2,2" extent="0,0.5,0.3333333,0.3333334" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(222,229,155);">
    <p>{X=0,Y=0.5,Width=0.3333333,Height=0.3333334}
    3 ,0 ,2 ,2 </p>
    </div>
    <div id="element_9" cell="5,3,1,3" extent="0.6666667,0.5,0.1666667,0.5" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(171,0,176);">
    <p>{X=0.6666667,Y=0.5,Width=0.1666667,Height=0.5}
    3 ,5 ,3 ,1 </p>
    </div>
    <div id="element_10" cell="6,3,1,3" extent="0.8333334,0.5,0.1666667,0.5" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(97,17,235);">
    <p>{X=0.8333334,Y=0.5,Width=0.1666667,Height=0.5}
    3 ,6 ,3 ,1 </p>
    </div>
    <div id="element_11" cell="2,4,3,1" extent="0.3333333,0.6666667,0.3333333,0.1666667" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(18,245,203);">
    <p>{X=0.3333333,Y=0.6666667,Width=0.3333333,Height=0.1666667}
    4 ,2 ,1 ,3 </p>
    </div>
    <div id="element_12" cell="0,5,1,1" extent="0,0.8333334,0.1666667,0.1666667" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(253,130,190);">
    <p>{X=0,Y=0.8333334,Width=0.1666667,Height=0.1666667}
    5 ,0 ,1 ,1 </p>
    </div>
    <div id="element_13" cell="1,5,4,1" extent="0.1666667,0.8333334,0.5,0.1666667" style="overflow-x:auto;overflow-y:hidden;border-style:solid;background-color:rgb(38,119,255);">
    <p>{X=0.1666667,Y=0.8333334,Width=0.5,Height=0.1666667}
    5 ,1 ,1 ,4 </p>
    </div>    
   
</body>
<script>
  var rowPlacer = null;

  function myFunction() {

  }

  function onPageLoad() {
    onResize();
  }
  
  class Extent
  {
    x = 0;
    y = 0;
    width = 0;
    height = 0;

    constructor(x,y,width,height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }

    get left() { return this.x;}
    set left(value) {extent.x = value; }
    get top() { return this.y;}
    set top(value) {extent.y = value; }
    get right() { return this.x + this.width;}
    get bottom() { return this.y + this.height;}

    intersects(extent)
    {
      if(extent.left >= this.right || extent.right <= this.left || extent.top >= this.bottom || extent.bottom <= this.top){
        return false;
      }
      return true;
    }

    intersect(extent)
    {
      if(this.intersects(extent) == false)
         return null;
      var newLeft = Math.max(this.left, extent.left);
      var newRight = Math.min(this.right, extent.right);
      var newTop = Math.max(this.top, extent.top);
      var newBottom = Math.min(this.bottom, extent.bottom);
      return new Extent(newLeft, newTop, newRight - newLeft, newBottom - newTop);
    }

    contains(extent)
    {
      if(this.left <= extent.left && this.right >= extent.right && this.top <= extent.top && this.bottom >= extent.bottom){
        return true;
      }
      return false;
    }
  }

  class GridElement {
    name = "";
    x = 0;
    y = 0;
    width = 0;
    height = 0;
    contentHeight = 0;
    div = null;
    cellExtent = null;
    extent = null;
    row = 0;
    column = 0;
    rowSpan = 1;
    columnSpan = 1;
    constructor(name,div,x,y,width,height,column,row,colSpan,rowSpan,contentHeight) {
      this.cellExtent = new Extent(column,row,colSpan,rowSpan);
      this.extent = new Extent(x,y,width,height);
      this.name = name;
      this.div = div;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.row = row;
      this.column = column;
      this.rowSpan = rowSpan;
      this.columnSpan = colSpan;
      this.contentHeight = contentHeight;
    }
  }

//A class that rearranges the elements horizontally based on their actual content size.
  class ContentDrivenGrid {
  
  elements = null;
  rows = 0;
  columns = 0;
  rowEdgeOffsetsInPercent = null;
  rowEdgeOffsetsInPixel = null;

  constructor(elements, rows, columns, rowEdgeOffsetsInPercent) {
    this.elements = elements;
    this.rows = rows;
    this.columns = columns;
    this.rowEdgeOffsetsInPercent = rowEdgeOffsetsInPercent;
    this.rowEdgeOffsetsInPixel = [];
    for(var i = 0; i < rows + 1; i++){
      this.rowEdgeOffsetsInPixel.push(-1);
    }
    this.gridCells = [];
    for(var row = 0; row < this.rows; row++){
      var gridCellRow = [];
      for(var col = 0; col < this.columns; col++){
        gridCellRow.push(null);
      }
      this.gridCells.push(gridCellRow);
    }
    for(var i = 0; i < this.elements.length; i++){
       var element = this.elements[i];
       this.gridCells[element.row][element.column] = element;
    }

    this.placeElements();
    this.compactVerticalSpace();
  }

  get PercentTop() { return this.extent.top; }
  set PercentTop(value) {this.extent.top = value; }
  get PercentLeft() { return this.extent.left; }
  set PercentLeft(value) {this.extent.left = value; }
  get PercentWidth() { return this.extent.Width; }
  set PercentWidth(value) {this.extent.width = value; }
  get PercentHeight() { return this.extent.height; }
  set PercentHeight(value) {this.extent.height = value; }

  interpolateRows(startEdge, endEdge)
  {
    if(startEdge < 0){startEdge = 0;}
    if(startEdge > this.rows){startEdge = this.rows;}
    if(endEdge < 0){endEdge = 0;}
    if(endEdge > this.rows){endEdge = this.rows;}

    for(var edge = startEdge; edge <= endEdge; edge++){
      var edgeOffset = this.rowEdgeOffsetsInPixel[edge];
      if (edgeOffset > -1){continue;}
      var interpolationStart = edge;
      var interpolationEnd = edge;
      while(interpolationStart >= 0){
           if(this.rowEdgeOffsetsInPixel[interpolationStart] > -1){break;}
           interpolationStart--;
      }
      while(interpolationEnd <= this.rows){
           if(this.rowEdgeOffsetsInPixel[interpolationEnd] > -1){break;}
           interpolationEnd++;
      }

      if(interpolationEnd > this.rows){interpolationEnd = this.rows;}
      //None of the succeeding edges have been set
      //Will fall back to extrapolation
      if(this.rowEdgeOffsetsInPixel[interpolationEnd] <= -1){
         for(var edgeToSet = interpolationStart; edgeToSet < interpolationEnd-1; edgeToSet++){
         this.rowEdgeOffsetsInPixel[edgeToSet+1] = this.extrapolateRowEdge(interpolationStart, edgeToSet + 1, this.rowEdgeOffsetsInPixel[interpolationStart]);
        }
        return;
      }

      var startOffset = this.rowEdgeOffsetsInPixel[interpolationStart];
      var endOffset = this.rowEdgeOffsetsInPixel[interpolationEnd];
      var summedFractions = 0;
      var summedOffset = endOffset-startOffset;
      var fractions = []
      for(var edgeToSet = interpolationStart; edgeToSet < interpolationEnd; edgeToSet++){
        var topEdge = edgeToSet;  
        var bottomEdge = edgeToSet+1;
        var diff = this.rowEdgeOffsetsInPercent[bottomEdge]-this.rowEdgeOffsetsInPercent[topEdge];
        fractions.push(diff);
        summedFractions += diff;
      }

      for(var edgeToSet = interpolationStart; edgeToSet < interpolationEnd-1; edgeToSet++){
        this.rowEdgeOffsetsInPixel[edgeToSet+1] = startOffset + summedOffset * (fractions[edgeToSet-interpolationStart]/summedFractions);
      }
    }
  }

  //Extrapolate the position at targetEdge based on baseEdge and the edge that precedes baseEdge. 
  extrapolateRowEdge(baseEdge, targetEdge, estimatedOffset)
  {
    if(baseEdge < 1 || baseEdge > this.rows){return estimatedOffset;}
    if(targetEdge < 2 || targetEdge > this.rows || targetEdge <= baseEdge){return estimatedOffset;}

    var baseEdgeOffset = this.rowEdgeOffsetsInPixel[baseEdge];
    if (baseEdgeOffset <= -1){return estimatedOffset;}
    var preToBaseEdge = baseEdge - 1;
    while(preToBaseEdge >= 0){
      if(this.rowEdgeOffsetsInPixel[preToBaseEdge] > -1){break;}
      preToBaseEdge--;
    }
    if(preToBaseEdge == baseEdge || this.rowEdgeOffsetsInPixel[preToBaseEdge] <= -1){return estimatedOffset;}

    var summedFractions = this.rowEdgeOffsetsInPercent[baseEdge] - this.rowEdgeOffsetsInPercent[preToBaseEdge];
    var summedOffset = this.rowEdgeOffsetsInPixel[baseEdge] - this.rowEdgeOffsetsInPixel[preToBaseEdge];
    if(summedFractions <= 0 || summedOffset <= 0){return estimatedOffset;}

    var deltaOffset = summedOffset/summedFractions;
    var fraction = this.rowEdgeOffsetsInPercent[targetEdge] - this.rowEdgeOffsetsInPercent[baseEdge];
    if(summedFractions <= 0 || summedOffset <= 0){return estimatedOffset;}

    return this.rowEdgeOffsetsInPixel[baseEdge] + fraction * deltaOffset;
  }

  placeElement(row, col)
  {
    var gridCell = this.gridCells[row][col];
    if (typeof(gridCell) == 'undefined' || gridCell == null){
      return;
    }
    var element = gridCell;
    var topEdge = row;
    var bottomEdge = topEdge + element.rowSpan;

    if(topEdge==0){
      this.rowEdgeOffsetsInPixel[topEdge] = 0;
      this.rowEdgeOffsetsInPixel[bottomEdge] = element.contentHeight;
      return;
    }
    
    var estimatedOffset = this.rowEdgeOffsetsInPixel[topEdge] + element.contentHeight;
    if(estimatedOffset < this.rowEdgeOffsetsInPixel[bottomEdge]){
      estimatedOffset = this.rowEdgeOffsetsInPixel[bottomEdge];
    }else{
      var preEdge = bottomEdge - 1;
      while(preEdge > 0){
         //The estimated offset of the current topEdge is less than that of an preceding topEdge
         //Will extrapolate the offset from the preceding topEdge
         if(this.rowEdgeOffsetsInPixel[preEdge] >= estimatedOffset){
          //estimatedOffset = this.extrapolateRowEdge(preEdge, bottomEdge, estimatedOffset);
          estimatedOffset = this.rowEdgeOffsetsInPixel[preEdge];
          break;
         }
         preEdge--;
      }
      this.rowEdgeOffsetsInPixel[bottomEdge] = estimatedOffset;
    }
    
    var edgeToSet = bottomEdge - 1;
    var toInterpolate = false;
    var interpolateStart = topEdge;
    var interpolateEnd = bottomEdge - 1;
    while(edgeToSet >= topEdge){
      if(this.rowEdgeOffsetsInPixel[edgeToSet] >= estimatedOffset){
        this.rowEdgeOffsetsInPixel[edgeToSet] = -1;//reset to be interpolated
        toInterpolate = true;
        interpolateStart = edgeToSet;
      }
      else if (this.rowEdgeOffsetsInPixel[edgeToSet] > -1){
        //The offset of the topEdge is less than that of the preceding topEdge
        //Will interpolate the offset from the preceding topEdge
        if(edgeToSet - 1 > 0 && this.rowEdgeOffsetsInPixel[edgeToSet - 1] > -1 && this.rowEdgeOffsetsInPixel[edgeToSet - 1] > this.rowEdgeOffsetsInPixel[edgeToSet]){
          this.rowEdgeOffsetsInPixel[edgeToSet - 1] = -1;//reset to be interpolated
          toInterpolate = true;
          interpolateStart = edgeToSet;
        }
      }
      edgeToSet--;
    }

    if(toInterpolate == true){
      this.interpolateRows(interpolateStart, interpolateEnd);
    }

    var edgeToSet = bottomEdge + 1;
    var toInterpolate = false;
    var interpolateStart = bottomEdge;
    var interpolateEnd = bottomEdge;
    while(edgeToSet <= this.rows){
      if(this.rowEdgeOffsetsInPixel[edgeToSet] > -1 && this.rowEdgeOffsetsInPixel[edgeToSet] <= estimatedOffset){
        this.rowEdgeOffsetsInPixel[edgeToSet] = -1;//reset to be interpolated
        toInterpolate = true;
        interpolateEnd = edgeToSet;
      }
      else if (this.rowEdgeOffsetsInPixel[edgeToSet] > -1){
      //The offset of a succeeding topEdge is less than that of the current topEdge
      //Will reset and interpolate the topEdge
      if(edgeToSet + 1 <= this.rows && this.rowEdgeOffsetsInPixel[edgeToSet + 1] > -1 && this.rowEdgeOffsetsInPixel[edgeToSet + 1] <= this.rowEdgeOffsetsInPixel[edgeToSet]){
          this.rowEdgeOffsetsInPixel[edgeToSet - 1] = -1;//reset to be interpolated
          toInterpolate = true;
          interpolateStart = edgeToSet;
        }
      }
      edgeToSet++;
    }
    if(toInterpolate == true){
      this.interpolateRows(interpolateStart, interpolateEnd);
    }
  }
  
  placeElements()
  {    
    for(var i = 0; i < this.rowEdgeOffsetsInPixel.length; i++){
      this.rowEdgeOffsetsInPixel[i] = -1;
    }
    for(var row = 0; row < this.rows; row++){
      for(var col = 0; col < this.columns; col++){
        this.placeElement(row, col);
      }
    }
    return this.rowEdgeOffsetsInPixel;
  }

  getElement(row, col)
  {
    var gridCell = this.gridCells[row][col];
    if (typeof(gridCell) == 'undefined' || gridCell == null){
      return null;
    }
    return gridCell;
  }

  compactVerticalSpace()
  {
    var row = 0;
    var rowFlags = []
    for (var n = 0; n < this.rows; n++)
    {
      rowFlags.push(-1);
    }
  
    while(row < this.rows) {
      var elementsInRow = [];
      var topEdge = row;
      var bottomEdge = row + 1;
      for(var n = 0;n < this.elements.length; n++){
        var elementInRow = this.elements[n];
        if(elementInRow.cellExtent.top <= topEdge && elementInRow.cellExtent.bottom >= bottomEdge){
          elementsInRow.push(elementInRow);
        }
      }
      row++;
      if(elementsInRow.length < 1){continue;}

      var intersectedArea = new Extent(0, elementsInRow[0].row, 1, elementsInRow[0].rowSpan);
      for(var n = 1; n < elementsInRow.length; n++){
        intersectedArea = intersectedArea.intersect(new Extent(0, elementsInRow[n].row, 1, elementsInRow[n].rowSpan));
        if(intersectedArea == null){break;}
      }
      //No shared rows to remove.
      if(intersectedArea == null || intersectedArea.height < 1){continue;}

      var handled = false;
      for(var n = intersectedArea.top; n < intersectedArea.bottom; n++){
        if(rowFlags[intersectedArea.top] > 0){
          handled = true;
          break;
        }
      }

      if(handled == true){
        break;
      }

      var extraSpace = Number.MAX_VALUE;
      var summedOffset = this.rowEdgeOffsetsInPixel[intersectedArea.bottom] - this.rowEdgeOffsetsInPixel[intersectedArea.top];
      for(var n = 0; n < elementsInRow.length; n++){
        var topEdge = elementsInRow[n].cellExtent.top;
        var bottomEdge = elementsInRow[n].cellExtent.bottom;
        var fraction = summedOffset/(this.rowEdgeOffsetsInPixel[bottomEdge] - this.rowEdgeOffsetsInPixel[topEdge]);
        var extraSpaceInRow = this.rowEdgeOffsetsInPixel[bottomEdge] - this.rowEdgeOffsetsInPixel[topEdge] - elementsInRow[n].contentHeight;
        extraSpaceInRow = extraSpaceInRow * fraction;
        if(extraSpace > extraSpaceInRow){
          extraSpace = extraSpaceInRow;
        }
      }
      //No empty space left to reduce
      if(extraSpace <= 1){continue;}

      var reducedSpace = 0;
      for(var n = intersectedArea.top; n < intersectedArea.bottom; n++){
        rowFlags[intersectedArea.top] = 1;
        var fraction = (this.rowEdgeOffsetsInPixel[n + 1] - this.rowEdgeOffsetsInPixel[n])/summedOffset;
        this.rowEdgeOffsetsInPixel[n + 1] = this.rowEdgeOffsetsInPixel[n + 1] - (extraSpace * fraction) - reducedSpace;
        reducedSpace += (extraSpace * fraction);
      }

      for(var n = intersectedArea.bottom + 1; n < this.rowEdgeOffsetsInPixel.length; n++){
        this.rowEdgeOffsetsInPixel[n] = this.rowEdgeOffsetsInPixel[n] - extraSpace;
      }
    }
  }

  getRowEdgePositionsInPercent()
  {
    var cellsOrderedByRow = [];
    for (var row = 0; row < this.rows; row++)
    {
      var topEdge = row;
      var bottomEdge = row + 1;
      var elementsInRow = [];
      for(var n = 0;n < this.elements.length; n++){
        var elementInRow = this.elements[n];
        if(elementInRow.top <= topEdge && elementInRow.bottom >= bottomEdge){
          elementsInRow.push(elementInRow);
        }
      }
      cellsOrderedByRow.push(cellsOrderedByRow);
    }

    var rowHeights = [];
    var rowEdges = [];
    rowEdges.push(0);
    for (var row = 0; row < this.rows; row++)
    {
      rowEdges.push(null);
      rowHeights.push(null);
    }

      //Pass 1:
      //(1) For a single-row element, the row height is determined by the element height;
      //(2) For a contiguous group of rows in which all elements are of equal row span, the row of each row is determined by evenly distributing the element height over all the rows;
      //(3) For a contiguous group of rows in which the rows of one element are shared by all the other elements, the heights of these overlapping rows are determined by dividing the height by the row span of that element;
      //(4) The top/bottom edge of a element determines the position of the corresponding row edge, e.g., the edge position of row 0 is the same as the top edge of an element whose starts at row 0.
      for (var row = 0; row < this.rows; row++)
      {
        if (rowHeights[row] != null){continue;}

        var intersectingCells = cellsOrderedByRow[row];
        var topEdge = row;
        var bottomEdge = row + 1;
        if (intersectingCells == null || intersectingCells.length == 0)
        {
          rowHeights[row] = 0;
          rowEdges[bottomEdge] = rowEdges[topEdge];
          continue;
        }

        var isUniformSpan = true;
        var minSpanRowId = 0;
        var rowSize = null;
        var id = -1;
        //System.Drawing.Rectangle overlappedExtent = intersectingCells[0].CellExtent;
        //overlappedExtent = new System.Drawing.Rectangle(overlappedExtent.X, 0, overlappedExtent.Height, 1);
        for (var n = 0; n < intersectingCells.length; n++)
        {
          var cell = intersectingCells[n];
          id++;
          rowEdges[cell.row] = cell.extent.top;
          rowEdges[cell.row + cell.rowSpan] = cell.extent.bottom;
          if (isUniformSpan && (cell.row != intersectingCells[0].row || cell.rowSpan != intersectingCells[0].rowSpan))
            isUniformSpan = false;
          //overlappedExtent.Intersect(new System.Drawing.Rectangle(cell.CellExtent.X, 0, cell.CellExtent.Height, 1));
          if (cell.rowSpan == 1)
          {
            rowSize = cell.percentHeight;
            break;
          }
          if (cell.rowSpan < intersectingCells[minSpanRowId].rowSpan)
          {
            minSpanRowId = id;
          }
        }

        rowHeights[row] = rowSize;
        if (rowSize == null)
        {
          if (isUniformSpan)
          {
            rowHeights[row] = intersectingCells[0].percentHeight / intersectingCells[0].rowSpan;
          }
          else
          {
            var hasOverlappingExtent = true;
            var minSpanCell = intersectingCells[minSpanRowId];
            var minSpanCellExtent = new Extent(0, minSpanCell.row, 1, minSpanCell.rowSpan);
            for (var m = 0; m < intersectingCells.length; m++)
            {
              var cellExtent = new Extent(0, intersectingCells[m].row, 1, intersectingCells[m].rowSpan);
              if (cellExtent.contains(minSpanCellExtent) == false)
              {
                hasOverlappingExtent = false;
                break;
              }
            }

            if (hasOverlappingExtent)
            {
              rowSize = minSpanCell.percentHeight / minSpanCell.rowSpan;
              rowHeights[row] = rowSize;
              for (var rowToSet = minSpanCell.row; rowToSet < minSpanCell.row + minSpanCell.rowSpan; rowToSet++)
              {
                rowHeights[rowToSet] = rowSize;
              }
            }
          }
        }
      }

      //Pass 2:
      //(1) For a multi-row element, if the row heights of all but one row are knowned, the unknown row height is determined by subtracting the summed height of the knowned rows from the element height;
      for (var row = 0; row < this.rows; row++)
      {
        if (rowHeights[row] != null){continue;}

        var intersectingCells = cellsOrderedByRow[row];
        for (var n = 0; n < intersectingCells.length; n++)
        {
          var cell = intersectingCells[n];
          if (cell.rowSpan == 1 && rowHeights[cell.row] != null)
          {
            rowHeights[row] = cell.percentHeight;
            break;
          }
          var rowSize = cell.percentHeight;
          var isSet = true;
          for (var rowToGet = cell.row; rowToGet < cell.row + cell.rowSpan; rowToGet++)
          {
            if (rowToGet == row){continue;}
              
            if (rowHeights[rowToGet] == null)
            {
              isSet = false;
              break;
            }
            rowSize -= rowHeights[rowToGet];
          }

          if (isSet == true){rowHeights[row] = rowSize;} 
        }
      }

      //Pass 3:
      //(1) First pass to determine positions at edges where both the positions of the top neighboring edge and the row height are known.
      for (var row = 0; row < this.rows; row++)
      {
        var topEdge = row;
        var bottomEdge = row + 1;
        if (rowEdges[topEdge] == null || rowHeights[row] == null){continue;}
 
        rowEdges[bottomEdge] = rowEdges[topEdge] + rowHeights[row];
      }

      //Pass 4:
      //(1) For a contiguous group of rows shared by all overlapping elements across the rows, the total height of these rows are is equal to the difference of the bottom edge and top edge positions (if both are known), and the total height is evenly distributed over the rows to determine the row height;
      for (var row = 0; row < this.rows; row++)
      {
        if (rowHeights[row] != null){continue;}
          
        if (rowEdges[row] == null){continue;}
 
        var startRow = row;
        var endRow = row;
        while (endRow < this.rows - 1)
        {
          if (rowHeights[endRow] != null)
          {
            endRow--;
            break;
          }
          endRow++;
        }
        var topEdge = row;
        var bottomEdge = endRow + 1;
        while (bottomEdge > topEdge)
        {
          if (rowEdges[bottomEdge] == null){
            bottomEdge--;
          }else{
            break;
          }

        }
        if (rowEdges[topEdge] == null || rowEdges[bottomEdge] == null){continue;}

        var rowSize = (rowEdges[bottomEdge] - rowEdges[topEdge]) / (endRow - startRow + 1);
        while (startRow <= endRow)
        {
          rowHeights[startRow] = rowSize;
          startRow++;
        }
        for (var rowToSet = 0; rowToSet < this.rows; rowToSet++)
        {
          if (rowEdges[rowToSet + 1] != null){continue;}

          if (rowEdges[rowToSet] == null || rowHeights[rowToSet] == null){continue;}

          rowEdges[rowToSet + 1] = rowEdges[rowToSet] + rowHeights[rowToSet];
        }
      }

      //Pass 5:
      //(1) Second pass to determine positions at unkown edges where both the positions of the top neighboring edge and the row height are known.
      for (var row = 0; row < this.rows; row++)
      {
        if (rowEdges[row + 1] != null){continue;}

        var topEdge = row;
        var bottomEdge = row + 1;
        if (rowEdges[topEdge] == null || rowHeights[row] == null){continue;}

        rowEdges[bottomEdge] = rowEdges[topEdge] + rowHeights[row];
      }

      //Return true only if all edges are known.
      success = true;
      for (var row = 0; row < Rows; row++)
      {
        if (rowEdges[row + 1] == null || rowHeights[row] == null)
          success = false;
      }
      alert(success);
      return rowEdges;
  }
}

  function onResize(){
    var layoutMargin = 5;
    var clientWidth = window.innerWidth - layoutMargin * 2;
    var clientHeight = window.innerHeight;
    var divs = document.body.getElementsByTagName("div");
    var rowEdgeOffsetsInPercent = ("0,0.3333333,0.4166667,0.5,0.6666666,0.8333333,1").split(",").map(function(item) {
        return parseFloat(item);
    });
 
    var margin = 5;
    var scrollbarWidth = 25;

    if(rowPlacer == null){
      var elements = [];
      var rows = 0;
      var columns = 0;  
      for(var i = 0; i < divs.length; i++){
         var elementDiv = divs[i];
         if(!elementDiv.id.startsWith("element_")){ continue; }
         var extent = elementDiv.getAttribute("extent").split(",");
         var xPercent=parseFloat(extent[0]);
         var yPercent=parseFloat(extent[1]);
         var wPercent=parseFloat(extent[2]);
         var hPercent=parseFloat(extent[3]);
         var contentHeight = elementDiv.scrollHeight + margin + scrollbarWidth;
         var cell = elementDiv.getAttribute("cell").split(",");
         var col=parseInt(cell[0]);
         var row=parseInt(cell[1]);
         var colSpan=parseInt(cell[2]);
         var rowSpan=parseInt(cell[3]);
         var element = new GridElement(elementDiv.id,elementDiv,xPercent,yPercent,wPercent,hPercent,col,row,colSpan,rowSpan,contentHeight);
         elements.push(element);
         if(rows < row+rowSpan) {rows = row+rowSpan;}
         if(columns < col+colSpan) {columns = col+colSpan;}
       }
       this.rowPlacer = new ContentDrivenGrid(elements, rows, columns, rowEdgeOffsetsInPercent);
    }
  
    for(var i = 0; i < this.rowPlacer.elements.length; i++){
       var element = this.rowPlacer.elements[i];
       var left = clientWidth * element.x + layoutMargin;
       var top = this.rowPlacer.rowEdgeOffsetsInPixel[element.row] + layoutMargin;
       var bottom = this.rowPlacer.rowEdgeOffsetsInPixel[element.row+element.rowSpan] + layoutMargin;
       var width = clientWidth * element.width - margin;
       var height = bottom - top;
       height = height - margin;
       
       element.div.style.maxWidth = width.toString() + "px";
       element.div.style.width = width.toString() + "px";
       element.div.style.minWidth = width.toString() + "px";
       element.div.style.maxHeight = height.toString() + "px";
       element.div.style.height = height.toString() + "px";
       element.div.style.minHeight = height.toString() + "px";
       element.div.style.left = left.toString() + "px";
       element.div.style.top = top.toString() + "px";
       element.div.style.position = "absolute";
    }
  };
</script>
</html>